# Анализ ошибки SSL Memory Allocation Failed

## Описание проблемы

Через несколько часов работы на двух из трех одинаковых устройств ESP32 перестали проходить POST запросы к серверу. В логах появляется следующая ошибка:

```
POST /api/lora HTTP/1.1
Host: xx.xx.xx.xx
User-Agent: curl/7.81.0
Content-Type: application/json
Content-Length: 168
Connection: close

{"user_id":"Guest","user_location":"Home","sender_nodeid":"726B6088","destination_nodeid":"FFFFFFFF","full_packet_len":97,"signal_level_dbm":113,"cold":5016,"hot":3198}

[38253493][E][ssl_client.cpp:37] _handle_error(): [start_ssl_client():264]: (-32512) SSL - Memory allocation failed
[38253503][E][WiFiClientSecure.cpp:144] connect(): start_ssl_client: -32512
[38253511][E][wifi_manager.cpp:491] doHttpPostFromData(): [WiFiManager] Cannot connect to server 84.252.143.212
```

## Анализ причины

Ошибка **-32512 (SSL - Memory allocation failed)** указывает на то, что ESP32 не может выделить достаточное количество памяти для создания SSL контекста при подключении к HTTPS серверу.

### Ключевые наблюдения:
1. **Временной фактор**: Ошибка появляется только через несколько часов работы
2. **Селективность**: Проблема затрагивает 2 из 3 идентичных устройств
3. **Тип подключения**: Используется HTTPS (WiFiClientSecure), а не обычный HTTP
4. **Частота запросов**: Устройства активно отправляют POST запросы (видно по счетчикам cold:5016, hot:3198)

### Коренная причина:
**Фрагментация и исчерпание heap памяти ESP32-C3**

#### Почему это происходит:
- **ESP32-C3 имеет ограниченную RAM**: 400KB SRAM total, из которой heap составляет около 280-320KB (зависит от конфигурации)
  - ROM: 384KB
  - RTC SRAM: 16KB
  - Оставшаяся SRAM для heap и стеков: ~280-320KB
- **WiFiClientSecure требует значительных ресурсов** для SSL/TLS (ESP32-C3 с RISC-V ядром):
  - **Базовый SSL контекст**: ~15-25KB на соединение
  - **Буферы шифрования**: ~8-16KB для AES/RSA операций
  - **Сертификаты сервера**: ~4-8KB при валидации цепочки
  - **SSL handshake данные**: ~5-10KB временных буферов
  - **JSON обработка**: ~2-4KB для формирования POST данных
  - **Итого на одно HTTPS подключение**: **35-65KB**
- **Фрагментация heap**: После часов работы с частым выделением/освобождением памяти (POST запросы каждые 30 сек, обработка LoRa пакетов, логирование) heap становится сильно фрагментированным
- **Пиковые нагрузки**: Одновременная обработка нескольких LoRa пакетов и отправка POST может вызвать пиковое потребление >100KB

#### Почему на двух устройствах, а не на всех трех:
- Различия в условиях работы (количество LoRa пакетов, интенсивность сетевой активности)
- Различия в начальном состоянии памяти
- Случайные факторы фрагментации

## Возможные решения

### 1. Мониторинг памяти
```cpp
// Добавить в WiFiManager::doHttpPost() или doHttpPostFromData()
ESP_LOGI(TAG, "Heap before POST: %d bytes free", ESP.getFreeHeap());
ESP_LOGI(TAG, "Min heap ever: %d bytes", ESP.getMinFreeHeap());

// После создания WiFiClientSecure
ESP_LOGI(TAG, "Heap after SSL client creation: %d bytes free", ESP.getFreeHeap());
```

### 2. Оптимизация использования памяти
- **Переиспользование SSL клиента**: Вместо создания нового WiFiClientSecure для каждого запроса, поддерживать постоянное подключение
- **Пулы памяти**: Использовать предварительно выделенные буферы вместо динамического выделения
- **Уменьшение размера буферов**: Проверить и оптимизировать размеры внутренних буферов

### 3. Управление жизненным циклом SSL
```cpp
// Пример оптимизации в doHttpPostFromData()
static WiFiClientSecure* persistentClient = nullptr;

if (!persistentClient) {
    persistentClient = new WiFiClientSecure();
    if (USE_INSECURE_HTTPS) {
        persistentClient->setInsecure();
    }
    // Настроить клиент один раз
}

// Использовать persistentClient вместо создания нового
```

### 4. Периодическая перезагрузка SSL контекста
```cpp
// Добавить счетчик успешных запросов
static int requestCount = 0;
const int MAX_REQUESTS_BEFORE_RESET = 100;

if (++requestCount > MAX_REQUESTS_BEFORE_RESET) {
    // Пересоздать SSL клиент
    delete persistentClient;
    persistentClient = new WiFiClientSecure();
    requestCount = 0;
    ESP_LOGI(TAG, "SSL client reset after %d requests", MAX_REQUESTS_BEFORE_RESET);
}
```

### 5. Снижение нагрузки на память
- **Пакетная отправка**: Группировать несколько POST запросов в один, чтобы уменьшить частоту создания SSL соединений
- **Кэширование DNS**: Избегать частых DNS запросов
- **Оптимизация строк**: Использовать String.reserve() и избегать ненужных копирований

### 6. Диагностические улучшения
```cpp
// Добавить в loadSettings() или setup()
ESP_LOGI(TAG, "Initial heap: %d bytes", ESP.getFreeHeap());
ESP_LOGI(TAG, "Initial min heap: %d bytes", ESP.getMinFreeHeap());

// Периодический мониторинг в pingTask()
ESP_LOGD(TAG, "Periodic heap check: %d bytes free, min: %d", ESP.getFreeHeap(), ESP.getMinFreeHeap());
```

### 7. Альтернативные подходы
- **Переход на HTTP**: Если возможно, использовать незащищенный HTTP для снижения нагрузки на память
- **MQTT вместо HTTP**: Рассмотреть MQTT протокол, который более эффективен для IoT устройств
- **Сжатие данных**: Сжимать POST данные для уменьшения размера запросов

## Рекомендации по реализации

1. **Немедленные действия**:
   - Добавить мониторинг heap в логи
   - Проверить текущий уровень фрагментации

2. **Краткосрочные улучшения**:
   - Реализовать переиспользование SSL клиента
   - Добавить периодический сброс SSL контекста

3. **Долгосрочные решения**:
   - Оптимизировать управление памятью во всем приложении
   - Рассмотреть переход на более эффективные протоколы
   - Увеличить частоту перезагрузок устройств при обнаружении проблем

## Тестирование исправлений

- **Мониторинг heap**: Наблюдать за изменением свободной памяти в течение времени
- **Нагрузочное тестирование**: Запустить устройства в условиях, имитирующих часы работы
- **A/B тестирование**: Сравнить поведение устройств с разными версиями кода

## Заключение

Эта проблема типична для resource-constrained устройств вроде ESP32 при длительной работе с HTTPS. Решение требует комплексного подхода к управлению памятью и оптимизации сетевых операций. Реализация предложенных улучшений должна значительно повысить стабильность работы устройств.
